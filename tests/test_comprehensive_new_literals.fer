// Comprehensive test showcasing the new anonymous literal syntax
// This demonstrates the solution to the IDEN{} ambiguity problem

// ============================================================
// PROBLEM SOLVED: if IDEN {} ambiguity
// ============================================================
// Before: Parser couldn't distinguish between:
//   - if IDEN {} (identifier + block)
//   - if IDEN {} where {} is a struct/map literal
//
// Solution: Use {} for anonymous literals, no identifier needed
// ============================================================

// Test 1: Clear if statement - no ambiguity!
let x := 10;
if x {
    let result := 42;
}

// Test 2: Anonymous struct literal (inferred type)
let point := {
    .x = 100,
    .y = 200,
};

// Test 3: Anonymous struct with explicit type cast
type Point struct {
    .x: i32,
    .y: i32,
};

let p1 := {
    .x = 10,
    .y = 20,
} as Point;

// Test 4: Anonymous struct with type annotation
let p2: Point = {
    .x = 5,
    .y = 15,
};

// Test 5: Anonymous map literal (inferred type)
let config := {
    "host" => "localhost",
    "port" => 8080,
};

// Test 6: Anonymous map with explicit type cast
let m1 := {
    "a" => 1,
    "b" => 2,
} as map[str]i32;

// Test 7: Anonymous map with type annotation
let m2: map[str]i32 = {
    "x" => 100,
    "y" => 200,
};

// Test 8: Nested anonymous structures
let nested := {
    .name = "config",
    .point = {
        .x = 1,
        .y = 2,
    },
    .values = {
        "key1" => 10,
        "key2" => 20,
    },
};

// Test 9: In expressions - always treated as literals
let sum := point + {
    .x = 1,
    .y = 1,
};

// Test 10: Legacy .{} syntax still works (backward compatibility)
let legacy := .{
    .a = 1,
    .b = 2,
};

// ============================================================
// SUMMARY
// ============================================================
// ✓ {} is anonymous struct/map literal (inferred from content)
// ✓ {.field = val} → struct literal
// ✓ {key => val} → map literal  
// ✓ expr as Type → explicit type cast
// ✓ let x: Type = {} → type annotation
// ✓ if IDEN {} → no ambiguity! {} is always a block here
// ✓ .{} → legacy syntax still supported
// ============================================================
